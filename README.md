#k-NN με MPI
#Εργασία 2η (Ανανεωμένη αναφορά)
#####Γενιτσιφτσόπουλος Ηρακλής 8789 και Μπαρμπαρέσος Ιάσων 8863

Μετά την επίλυση ορισμένων τεχνικών προβλημάτων καταφέραμε να πάρουμε
μετρήσεις για τον χρόνο και έτσι ανεβάζουμε νέα αναφορά με επιπλέον
κώδικα και μετρήσεις.
###Σειριακή υλοποίηση κατασκευής δένδρου
Δυστυχώς, λόγω του ότι μετά απο μερικές επαναλήψεις, τα υποσύνολα του
αλγορίθμου γίνονται μικρότερα από των αριθμό των στοιχείων κάθε διεργασίας,
καθώς και της ανάγκης αποθήκευσης δενδρικής δομής αντί για την στοίβα που
χρησιμοποιείται από κάθε παράλληλη διεργασία, η σειριακή υλοποίηση είναι
εντελώς ξεχωριστή.
Αρχικά υπολογίζουμε των αριθμό των vantage point που θα χρειαστούμε, ο οποίος
ισούται με των αριθμό των στοιχείων στο dataset μείον 1. Στην συνέχεια
δημιουργούμε 2 πίνακες, έναν που αποθηκεύει τα vantage points σε συνεκτική
μορφή, το ένα μετά το άλλο, και έναν που αποθηκεύει τις διαμέσους των
αποστάσεων. Οι πίνακες χρησιμοποιούνται ως πλήρεις δυαδικοί σωροί (binary
heaps), δηλαδή ξεκινώντας από το μηδέν, το δεξί παιδί βρίσκεται στην θέση 2i + 2
ενώ το αριστερό στην 2i + 1.
Το δένδρο δημιουργείται αναδρομικά, χρησιμοποιώντας μια συνάρτηση
ταξινόμησης που βρήκαμε στο διαδύκτιο, που πρακτικά είναι μια παραλλαγή της
κοινής qsort() που μας επιτρέπει να περάσουμε ένα όρισμα στην συνάρτηση
συγκρίσεως. Αυτό το χρησιμοποιούμε για να συγκρίνουμε τα σημεία με βάσει την
απόστασή τους από το vantage point. Στην συνέχεια, η διάμεσος υπολογίζεται από
τον μέσο όρο των 2 κεντρικών στοιχείων. Έπειτα από μια σειρά διαδοχικών
ταξινομήσεων σταματάμε όταν ο κάθε κόμβος έχει 2 στοιχεία.
Η συνάρτηση verify_tree() επαληθεύει την ορθή δημιουργία του δένδρου
ελέγχοντας ότι τα στοιχεία που είναι αριστερά από την μέση απέχουν απόσταση
από το vantage point μικρότερη από την διάμεσο που αποθηκεύθηκε στο δένδρο,
ενώ εκτελούμε τον αντίστροφο έλεγχο για την δεξιά μεριά.
Στο unit test με όνομα test_vp_tree_local (), δημιουργούμε και επαληθεύουμε ένα
τυχαίο δένδρο μεγέθους 1024 στοιχείων. Με την εκτέλεση αυτού του τεστ μερικές
δεκάδες φορές είμαστε σίγουροι ότι η δημιουργία του δένδρου είναι σωστή. Για
περεταίρω έλεγχο με κόστος ταχύτητας, μπορούμε να κάνουμε define το σύμβολο
PEDANTIC_CHEKS, όπου και θα επαληθεύεται η κάθε ταξινόμηση που γίνεται.
###Παράλληλη υλοποίηση κατασκευής δένδρου
Για την δομή του παράλληλου δένδρου δημιουργούμε, όπως και στο σειριακό,
2 πίνακες που θα αποθηκεύουν τα vantage points και τις διαμέσους των αποστάσεων,
αλλά και ένα τοπικό δένδρο (VPTree). Αυτα συνθέτουν την δομή VPTreeDistributed.
Η κατασκευή του τοπικού δένδρου γίνεται όπως περιγράφεται παραπάνω.
Για την κατασκευή του διανεμημένου δένδρου χρησιμοποιούμε την συνάρτηση
vp_tree_dist_from_dataset που καλείται απο κάθε process παίρνοντας ως είσοδο
το dataset του κάθε process. Αρχικά παίρνουμε τα world_size και world_rank
με τις κλήσεις MPI_Comm_rank και MPI_Comm_size για τον communicator
MPI_COMM_WORLD και υπολογίζουμε το βάθος του δένδρου (μόνο το παράλληλο κομμάτι)
ως τον λογάριθμο με βάση το 2 του world_size. Ἐπειτα μέσα σε έναν βρόχο για i = 0
εώς tree_depth (που είναι log(world_size)) δημιουργούμε σε κάθε επίπεδο communicators για
κάθε υποομάδα και οι masters επιλέγουν το vantage point και το κάνουν broadcast.
Μετά με την συνάρτηση write_distances_from_vp κάθε process βρίσκει τις αποστάσεις των
σημείων του απο το vantage point και καλόντας την συνάρτηση get_median_distance απίρνουν την
διάμεσο των αποστάσεων. (Η διάμεσος τον αποστάσεων βρίσκεται μέσω των τροποποιημέννων masterPart
και slavePart που μας δόθηκαν και έπειτα γίνονται broadcast σε όλα τα processes απο τον master)
Μετά καλούμε την mpi_partition_value που αναδιανέμει τα στοιχεία με βάση την διάμεσο ώστε
αυτά που βρίσκονται στις πρώτες μισές διεργασίες να είναι μικρότερα της διαμέσου ενώ
τα υπόλοιπα να είναι μεγαλύτερα απο αυτήν. Έτσι το δένδρο γεμίζει τους πίνακες των medians και
των vantage points και τέλος βρίσκουμε όπως περιγράφηκε παραπάνω το local tree για την
κάθε διεργασία.
###Σειριακή εύρεση των k κοντινότερων γειτόνων
Για την εύρεση των k κοντινότερων γειτόνων τοπικά υλοποιήσαμε την συνάρτηση
vp_tree_search. Πρακτικά υλοποιούμε μια max_heap μέσω της συνάρτησης queue_insert
και έτσι καλούμε αναδρομικά την συνάρτηση vp_tree_search μέχρι να έχουμε δύο σημεία
όπου τότε τα εισάγουμε μέσα στο max_heap. Η αναδρομικές κλήσεις γίνονται ανάλογα με
την απόσταση του target απο το vantage point σε σχέση με την διάμεση απόσταση.
Εάν η απόσταση είναι μικρότερη της διαμέσου καλούμε την vp_tree_search για το αριστερό
υποδένδρο και εφόσον η μεγαλύτερη απόσταση απο τα σημεία που έχουμε βάλει ως τώρα στο queue
είναι μεγαλύτερη ἠ ίση του median -- distance καλούμε την συνάρτηση και για το δεξί υποδένδρο.
Αλλιώς αν η απόσταση είναι μεγαλύτερη της διαμέσου καλούμε την συνάρτηση για το δεξί υποδένδρο
και εφόσον η μεγαλυτερη απόσταση είναι μεγαλύτερη ή ίση του distance -- median την καλούμε και για το αριστερό υποδένδρο. Τέλος η vp_tree_find_knn δημιουργεί ένα καινούργιο σύνολο μεγέθους k, καλεί την vp_tree_search και επιστρέφει το knn.
###Παράλληλη εύρεση των k κοντινότερων γειτόνων
Για την παράλληλη εύρεση υλοποιήσαμε την συνάρτηση vp_tree_dist_find_knn πού δέχεται ως είσοδο ένα
δένδρο, το target που θέλουμε να βρούμε γείτονες καθώς και το k.
Στην συνάρτηση αυτή αρχικά βρίσκουμε τα τοπικά knn καλόντας την vp_tree_find_knn και μετά ξεκινώντας
από κάτω δημιουργούμε και πάλί communicators για κάθε υποομάδα. Έτσι ο κάθε master λαμβάνει τα σημεία 
που έχουν βρεθεί εώς τώρα στο υποδένδρο και τα βάζει στην max_heap όπως και στο τοπικό κομμάτι.
Στο τέλος λοιπόν ο master θα έχει τους k κοντινότερους γείνοτες απο όλο το δένδρο.
Τέλος αξίζει να αναφέρουμε ότι στην ανάπτυξη του κώδικά μας δώσαμε μεγάλη έμφαση στον έλεγχο 
θρθότητος υλοποιόντας πολλα unit tests. Ο αλγόριθμος εύρεσης k κοντινότερων γειτόνων αποτύγχανε 
στον έλεγχο ορθότητος σε ορισμένες εκτελέσεις.


######Διαγράμματα βρίσκονται στο wiki.


